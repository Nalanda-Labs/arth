/**
 *
 *  login.cc
 *  This file is generated by drogon_ctl
 *
 */

#include <string>

#include <drogon/HttpClient.h>
#include <trantor/utils/Logger.h>

#include "login.h"
#include "util/emailutils.h"
#include "util/jwt_impl.h"
#include "util/password.h"
#include "util/string_util.h"
#include "util/input_validation.h"

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void Login::doLogin(const HttpRequestPtr &req, Callback callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    if (json == nullptr)
    {
        ret["error"] = "Malformed request.";
        auto resp = jsonResponse(std::move(ret));
        callback(resp);

        return;
    }

    std::string username = trim(json->get("username", "").asString());
    std::string password = json->get("password", "").asString();
    std::string email = trim(json->get("email", "").asString());

    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;
    LOG_DEBUG << "email: " << email;

    EmailUtils::cleanEmail(email);

    LOG_DEBUG << "cleaned email: " << email;

    if (username == "" && email == "")
    {
        LOG_DEBUG << "Both username and email cannot be empty";
        ret["error"] = "Both username and email cannot be empty";
        callback(jsonResponse(std::move(ret)));
        return;
    }

    if (username != "" && email != "")
    {
        LOG_DEBUG << "Submit either username or email. Not both";
        ret["error"] = "Submit either username or email. Not both";
        callback(jsonResponse(std::move(ret)));
        return;
    }

    if (password == "")
    {
        LOG_DEBUG << "Password is empty";
        ret["error"] = "Password is empty";
        callback(jsonResponse(std::move(ret)));
        return;
    }

    LOG_DEBUG << "username valid? " << isUsernameValid(username);
    LOG_DEBUG << "email valid? " << isEmailValid(email);
    LOG_DEBUG << "password valid? " << isPasswordValid(password);

    if (!(isUsernameValid(username) || isEmailValid(email)) || !isPasswordValid(password))
    {
        LOG_DEBUG << "Invalid input";
        ret["error"] = "Invalid input";
        callback(jsonResponse(std::move(ret)));
        return;
    }

    {
        auto customConfig = app().getCustomConfig();

        std::string jwtSecret = customConfig.get("jwt_secret", "").asString();

        if (jwtSecret == "")
        {
            LOG_DEBUG << "JWT not configured properly";
            ret["error"] = "JWT not configured properly";
            callback(jsonResponse(std::move(ret)));
            return;
        }

        auto clientPtr = drogon::app().getFastDbClient("default");

        clientPtr->execSqlAsync(
            "select id, username_lower, password_hash, salt, email_verified from users where username = $1 or email = $2",

            [=](const Result &r) mutable {
                if (r.size() != 1)
                {
                    LOG_DEBUG << "User does not exist";
                    /// Prevents a class or error where attacker is trying to
                    /// guess usernames for a given password
                    ret["error"] = "Wrong username or password";
                    callback(jsonResponse(std::move(ret)));
                    return;
                }

                auto row = r[0];

                auto email_verified = row["email_verified"].as<bool>();
                if (!email_verified) {
                    LOG_DEBUG << "Email not verified";
                    ret["error"] = "Please verify your email before logging in";
                    callback(jsonResponse(std::move(ret)));
                    return;
                }

                auto password_hash = row["password_hash"].as<std::string>();
                auto salt = row["salt"].as<std::string>();


                if (PasswordUtils::verifyPassword(password, password_hash, salt)) {
                    auto user_id = row["id"].as<size_t>();
                    auto username_lower = row["username_lower"].as<std::string>();

                    LOG_DEBUG << "Log in successful";

                    ret["jwt"] = signJWT(user_id, username_lower, jwtSecret);
                    callback(jsonResponse(std::move(ret)));
                    return;
                }

                LOG_DEBUG << "Wrong username or password";
                /// Prevents a class or error where attacker is trying to
                /// guess usernames for a given password
                ret["error"] = "Wrong username or password";
                callback(jsonResponse(std::move(ret)));
            },
            [=](const DrogonDbException &e) mutable {
                LOG_DEBUG << e.base().what();
                ret["error"] = (std::string)e.base().what();
                callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
            },
            username,
            email);
    }
}
