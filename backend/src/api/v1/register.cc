/**
 *
 *  register.cc
 *  This file is generated by drogon_ctl
 *
 */

#include <string>

#include <drogon/HttpClient.h>

#include "register.h"

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void registration::doRegister(const HttpRequestPtr &req,
                              std::function<void(const HttpResponsePtr &)> &&callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    auto name = json->get("name", "").asString();
    auto email = json->get("email", "").asString();
    auto username = json->get("username", "").asString();
    auto password = json->get("password", "").asString();
    Json::Value token;
    if (json->isMember("token"))
        token = json->get("token", "");

    LOG_DEBUG << "name: " << name;
    LOG_DEBUG << "email: " << email;
    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;

    // always validate user input. never rely on what is coming from the other side
    if (name == "" || username == "" || email == "" || password == "")
    {
        ret["error"] = "None of the fields can be empty.";
        auto resp = HttpResponse::newHttpJsonResponse(std::move(ret));
        callback(resp);
    }

    if (token.isMember("isTrusted"))
    {
        auto customConfig = app().getCustomConfig();
        std::string secret = "";
        if (customConfig.isMember("recaptcha_secret") && customConfig.get("recaptcha_secret", "") != "")
        {
            secret = customConfig.get("recaptcha_secret", "").asString();
        }
        else
        {
            ret["error"] = "Recaptcha improperly configured.";
            auto resp = HttpResponse::newHttpJsonResponse(std::move(ret));
            callback(resp);
        }

        auto client = HttpClient::newHttpClient(
            "https://www.google.com/");
        auto req = HttpRequest::newHttpRequest();
        req->setMethod(drogon::Post);
        req->setPath("/recaptcha/api/siteverify");
        req->setParameter("secret", secret);
        req->setParameter("response", token.get("isTrusted", false).asString());

        client->sendRequest(
            req,
            [ret = ret, callback = callback](ReqResult result, const HttpResponsePtr &response) mutable {
                LOG_DEBUG << "received response!";
                // auto headers=response.
                std::shared_ptr<Json::Value> res = response->getJsonObject();
                if (res->isMember("success") && not res->get("success", false))
                {
                    ret["error"] = "Recaptcha test failed.";
                    auto resp = HttpResponse::newHttpJsonResponse(std::move(ret));
                    callback(resp);
                }
            });
    }
    else
    {
        ret["error"] = "Recaptcha token not found.";
        auto resp = HttpResponse::newHttpJsonResponse(std::move(ret));
        callback(resp);
    }

    // {
    // auto clientPtr = app().getFastDbClient("default");
    // assert(clientPtr);
    {
        auto clientPtr = drogon::app().getFastDbClient("default");
        clientPtr->newTransactionAsync([=](const std::shared_ptr<Transaction> &transPtr) mutable {
            assert(transPtr);
            transPtr->execSqlAsync(
                "select * from users where username=$1",
                [=](const Result &r) mutable {
                    if (r.size() > 0)
                    {
                        LOG_DEBUG << "User exists";
                        ret["error"] = "User exists";
                        callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                    }
                    else
                    {
                        auto username_lower = username;
                        transform(username_lower.begin(), username_lower.end(), username_lower.begin(), ::tolower);
                        LOG_DEBUG << username_lower;
                        *transPtr << "insert into users(username, created_at, updated_at, username_lower, trust_level) values($1, '2021-01-01T00:00:00', '2020-01-01T00:00:00', $2, 0);" << username << username_lower >> [=](const Result &r) mutable {
                            ret["username"] = username_lower;
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        } >> [=](const DrogonDbException &e) mutable {
                            LOG_ERROR << "err:" << e.base().what();
                            ret["error"] = (std::string)e.base().what();
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        };
                    }
                },
                [=](const DrogonDbException &e) mutable {
                    LOG_DEBUG << e.base().what();
                    ret["error"] = (std::string)e.base().what();
                    callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                },
                username);
        });
    }
}
