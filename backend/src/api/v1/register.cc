/**
 *
 *  register.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "register.h"
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void registration::doRegister(const HttpRequestPtr &req,
                              std::function<void(const HttpResponsePtr &)> &&callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    auto name = json->get("name", "").asString();
    auto email = json->get("email", "").asString();
    auto username = json->get("username", "").asString();
    auto password = json->get("password", "").asString();

    LOG_DEBUG << "name: " << name;
    LOG_DEBUG << "email: " << email;
    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;

    // always validate user input. never rely on what is coming from the other side
    if (name == "" || username == "" || email == "" || password == "")
    {
        ret["error"] = "None of the fields can be empty.";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        callback(resp);
    }

    // {
    // auto clientPtr = app().getFastDbClient("default");
    // assert(clientPtr);
    {
        auto clientPtr = drogon::app().getFastDbClient("default");
        clientPtr->newTransactionAsync([=](const std::shared_ptr<Transaction> &transPtr) mutable {
            assert(transPtr);
            transPtr->execSqlAsync(
                "select * from users",
                [=](const Result &r) mutable{
                    if (r.size() > 0)
                    {
                        LOG_DEBUG << "User exists";
                        ret["error"] = "User exists";
                        callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                    }
                    else
                    {
                        auto username_lower = username;
                        transform(username_lower.begin(), username_lower.end(), username_lower.begin(), ::tolower);
                        *transPtr << "insert into users(username, created_at, updated_at, username_lower, trust_level) values($1, '2021-01-01T00:00:00', '2020-01-01T00:00:00', $2, 0);" << username << username_lower >> [=](const Result &r) mutable {
                            ret["username"] = username_lower;
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        } >> [=](const DrogonDbException &e) mutable {
                            LOG_ERROR << "err:" << e.base().what();
                            ret["error"] = (std::string)e.base().what();
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        };
                    }
                },
                [=](const DrogonDbException &e) mutable {
                    LOG_DEBUG << e.base().what();
                    ret["error"] = (std::string)e.base().what();
                    callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                });
        });
    }
}
