/**
 *
 *  register.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "register.h"
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void registration::doRegister(const HttpRequestPtr &req,
                              std::function<void(const HttpResponsePtr &)> &&callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    auto name = json->get("name", "").asString();
    auto email = json->get("email", "").asString();
    auto username = json->get("username", "").asString();
    auto password = json->get("password", "").asString();

    LOG_DEBUG << "name: " << name;
    LOG_DEBUG << "email: " << email;
    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;

    // always validate user input. never rely on what is coming from the other side
    if (name == "" || username == "" || email == "" || password == "")
    {
        ret["error"] = "None of the fields can be empty.";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        callback(resp);
    }

    // {
    // auto clientPtr = app().getFastDbClient("default");
    // assert(clientPtr);
    {
        auto clientPtr = drogon::app().getFastDbClient("default");
        clientPtr->newTransactionAsync([ret=std::move(ret), callback=std::move(callback)](const std::shared_ptr<Transaction> &transPtr) {
            assert(transPtr);
            transPtr->execSqlAsync( "select * from users", 
            [=](const Result &r) {
                if(r.size() > 1) {
                    LOG_DEBUG << "User exists";
                    ret["error"] = "User exists";
                    callback(HttpResponse::newHttpJsonResponse(str::move(ret)));
                } else {
                    *transPtr << "insert into users(username, created_at, updated_at, username_lower, trust_level) values('shiv', '2021-01-01T00:00:00', '2020-01-01T00:00:00', 'shiv', 0);"
                }
            },
            [](const DrogonDbException &e) {
                LOG_DEBUG << e.base().what();
            });
        });
    }
}
