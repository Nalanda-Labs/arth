/**
 *
 *  register.cc
 *  This file is generated by drogon_ctl
 *
 */

#include <string>

#include <drogon/HttpClient.h>

#include "util/emailutils.h"
#include "util/datetime.h"
#include "register.h"

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void registration::doRegister(const HttpRequestPtr &req, Callback callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    auto name = json->get("name", "").asString();
    auto email = json->get("email", "").asString();
    auto username = json->get("username", "").asString();
    auto password = json->get("password", "").asString();
    Json::Value token;
    if (json->isMember("token"))
        token = json->get("token", "");

    LOG_DEBUG << "name: " << name;
    LOG_DEBUG << "email: " << email;
    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;

    // always validate user input. never rely on what is coming from the other side
    if (name == "" || username == "" || email == "" || password == "")
    {
        ret["error"] = "None of the fields can be empty.";
        callback(jsonResponse(std::move(ret)));
    }

    if (token.isMember("isTrusted"))
    {
        auto customConfig = app().getCustomConfig();
        std::string secret = "";
        if (customConfig.isMember("recaptcha_secret") && customConfig.get("recaptcha_secret", "") != "")
        {
            secret = customConfig.get("recaptcha_secret", "").asString();
        }
        else
        {
            ret["error"] = "Recaptcha improperly configured.";
            callback(jsonResponse(std::move(ret)));
        }

        auto client = HttpClient::newHttpClient(
                          "https://www.google.com/");
        auto req = HttpRequest::newHttpRequest();
        req->setMethod(drogon::Post);
        req->setPath("/recaptcha/api/siteverify");
        req->setParameter("secret", secret);
        req->setParameter("response", token.get("isTrusted", false).asString());

        client->sendRequest(
            req,
        [ret = ret, callback = callback](ReqResult result, const HttpResponsePtr & response) mutable {
            LOG_DEBUG << "received response!";
            // auto headers=response.
            std::shared_ptr<Json::Value> res = response->getJsonObject();
            if (res->isMember("success") && not res->get("success", false))
            {
                ret["error"] = "Recaptcha test failed.";
                callback(jsonResponse(std::move(ret)));
            }
        });
    }
    else
    {
        ret["error"] = "Recaptcha token not found.";
        callback(jsonResponse(std::move(ret)));
    }

    {
        auto clientPtr = drogon::app().getFastDbClient("default");
        clientPtr->newTransactionAsync([ = ](const std::shared_ptr<Transaction> &transPtr) mutable {
            assert(transPtr);
            EmailUtils::cleanEmail(email);

            if(email == "") {
                ret["error"] = "Invalid email.";
                callback(jsonResponse(std::move(ret)));
            } else {
                transPtr->execSqlAsync(
                    "select * from users where username=$1 or email=$2",
                [ = ](const Result & r) mutable {
                    if (r.size() > 0)
                    {
                        LOG_DEBUG << "User exists";
                        ret["error"] = "User exists";
                        callback(jsonResponse(std::move(ret)));
                    }
                    else
                    {
                        auto username_lower = username;

                        transform(username_lower.begin(), username_lower.end(), username_lower.begin(), ::tolower);
                        LOG_DEBUG << username_lower;

                        *transPtr << "insert into users(username, created_at, updated_at, username_lower, email, trust_level) \
                        values($1, '2021-01-01T00:00:00', '2020-01-01T00:00:00', $2, $3, 0);" 
                        << username << username_lower << email >> [ = ](const Result & r) mutable {
                            ret["username"] = username_lower;
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        } >> [ = ](const DrogonDbException & e) mutable {
                            LOG_ERROR << "err:" << e.base().what();
                            ret["error"] = (std::string)e.base().what();
                            callback(HttpResponse::newHttpJsonResponse(std::move(ret)));
                        };
                    }
                },
                [ = ](const DrogonDbException & e) mutable {
                    LOG_DEBUG << e.base().what();
                    ret["error"] = (std::string)e.base().what();
                    callback(jsonResponse(std::move(ret)));
                },
                username, email);
            }
        });
    }
}
